name: Continuous Deployment

on:
  push:
    branches: [ main ]
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [ main ]

env:
  REGISTRY: docker.io
  IMAGE_NAME: ${{ github.repository }}  # Uses your GitHub username/repo-name

jobs:
  # Build and push Docker images to registry
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    # Only run if CI workflow succeeded (when triggered by workflow_run)
    if: |
      github.event_name == 'push' || 
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Extract metadata for API image
      id: meta-api
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-api
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Extract metadata for Streamlit image
      id: meta-streamlit
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-streamlit
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push API Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.api
        push: true
        tags: ${{ steps.meta-api.outputs.tags }}
        labels: ${{ steps.meta-api.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
    
    - name: Build and push Streamlit Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.streamlit
        push: true
        tags: ${{ steps.meta-streamlit.outputs.tags }}
        labels: ${{ steps.meta-streamlit.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
    
    - name: Output image tags
      run: |
        echo "API Image: ${{ steps.meta-api.outputs.tags }}"
        echo "Streamlit Image: ${{ steps.meta-streamlit.outputs.tags }}"

  # Deploy to EC2
  deploy-ec2:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: build-and-push
    # Deploy on main branch pushes or after successful CI workflow
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
    
    - name: Detect EC2 App Directory
      id: detect-dir
      env:
        EC2_USER: ${{ secrets.EC2_USER || 'ec2-user' }}
        EC2_HOST: ${{ secrets.EC2_HOST }}
      run: |
        # If EC2_APP_DIR is explicitly set, use it
        if [ -n "${{ secrets.EC2_APP_DIR }}" ]; then
          echo "dir=${{ secrets.EC2_APP_DIR }}" >> $GITHUB_OUTPUT
          echo "‚úÖ Using configured EC2_APP_DIR: ${{ secrets.EC2_APP_DIR }}"
        else
          # Auto-detect the directory by searching for docker-compose.yml
          echo "üîç Auto-detecting app directory on EC2..."
          DETECTED_DIR=$(ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ env.EC2_USER }}@${{ env.EC2_HOST }} \
            "find ~ -name 'docker-compose.yml' -type f 2>/dev/null | head -1 | xargs dirname 2>/dev/null || echo ''")
          
          if [ -n "$DETECTED_DIR" ]; then
            echo "dir=$DETECTED_DIR" >> $GITHUB_OUTPUT
            echo "‚úÖ Auto-detected EC2_APP_DIR: $DETECTED_DIR"
          else
            # Fallback to default
            DEFAULT_DIR="~/ai-research-assistant"
            echo "dir=$DEFAULT_DIR" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Could not auto-detect, using default: $DEFAULT_DIR"
          fi
        fi
    
    - name: Deploy to EC2
      env:
        EC2_USER: ${{ secrets.EC2_USER || 'ec2-user' }}
        EC2_HOST: ${{ secrets.EC2_HOST }}
        EC2_APP_DIR: ${{ steps.detect-dir.outputs.dir }}
        DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
        DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
        DOCKER_IMAGE_API: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-api:latest
        DOCKER_IMAGE_STREAMLIT: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-streamlit:latest
      run: |
        echo "üì¶ Deploying to EC2_APP_DIR: ${{ env.EC2_APP_DIR }}"
        ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${{ env.EC2_USER }}@${{ env.EC2_HOST }} << ENDSSH
          set -e
          cd ${{ env.EC2_APP_DIR }}
          
          # Pull latest code
          git fetch origin
          git reset --hard origin/main
          
          # Log in to Docker Hub
          echo "${{ env.DOCKER_PASSWORD }}" | docker login -u "${{ env.DOCKER_USERNAME }}" --password-stdin
          
          # Pull latest images from Docker Hub
          docker pull ${{ env.DOCKER_IMAGE_API }}
          docker pull ${{ env.DOCKER_IMAGE_STREAMLIT }}
          
          # Stop existing containers
          docker compose -f docker-compose.yml -f docker-compose.prod.yml down || true
          
          # Create override file to use Docker Hub images instead of building
          cat > docker-compose.prod.override.yml << EOF
          services:
            api:
              image: ${{ env.DOCKER_IMAGE_API }}
            streamlit:
              image: ${{ env.DOCKER_IMAGE_STREAMLIT }}
          EOF
          
          # Start services with production config and override
          docker compose -f docker-compose.yml -f docker-compose.prod.yml -f docker-compose.prod.override.yml up -d
          
          # Clean up old images
          docker image prune -f
          
          # Verify deployment
          sleep 10
          curl -f http://localhost:8000/health || exit 1
          echo "‚úÖ Deployment successful!"
        ENDSSH
    
    - name: Verify deployment
      run: |
        sleep 5
        curl -f http://${{ secrets.EC2_HOST }}:8000/health || echo "‚ö†Ô∏è Health check failed - check logs on EC2"
